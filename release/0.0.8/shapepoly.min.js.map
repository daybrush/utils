{"version":3,"file":"shapepoly.min.js","sources":["../src/consts.ts","../src/index.ts"],"sourcesContent":["export const TOP = \"top\";\nexport const BOTTOM = \"bottom\";\nexport const LEFT = \"left\";\nexport const RIGHT = \"right\";\nexport type DIRECTION = \"top\" | \"bottom\" | \"left\" | \"right\";\nexport const REVERSE = {\n  [TOP]: BOTTOM,\n  [BOTTOM]: TOP,\n  [LEFT]: RIGHT,\n  [RIGHT]: LEFT,\n};\nexport const POLY_CLASS = \"__shape-poly\";\nexport const SIDE_CLASS = `${POLY_CLASS}-side`;\nexport const POSITION_ABSOLUTE = \"position:absolute;\";\nexport const SIDE_CSS = `${POSITION_ABSOLUTE}width:100%;height:100%;border-radius:inherit;\nbackground-color:inherit;transform-origin:inherit;`;\n","import {\n  BOTTOM, TOP, DIRECTION, SIDE_CLASS, POLY_CLASS,\n  POSITION_ABSOLUTE, REVERSE, LEFT, RIGHT, SIDE_CSS\n} from \"./consts\";\n\nfunction splitUnit(text: string) {\n  const matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text);\n\n  if (!matches) {\n    return { unit: \"\", value: NaN };\n  }\n  const value = matches[2];\n  const unit = matches[3];\n\n  return { unit, value: parseFloat(value) };\n}\nfunction getTransformOrigin(strokeWidth: string | number, isVertical: boolean) {\n  const x = isVertical ? strokeWidth : \"50%\";\n  const y = isVertical ? \"50%\" : strokeWidth;\n\n  return `transform-origin:${x} ${y};`;\n}\n\nfunction getHTML(no: number | string, style: string, content: string = \"\") {\n  return `<div class=\"${SIDE_CLASS}${no}\" style=\"${style}\">${content}</div>`;\n}\nfunction makeDOM(tag: string, className: string) {\n  const el = document.createElement(tag);\n\n  el.className = className;\n  return el;\n}\nfunction getSin(side: number) {\n  // sin([n / 2] * 180 / n)\n  return Math.sin(Math.floor(side / 2) * Math.PI / side);\n}\nfunction getCos(side: number) {\n  // cos(180 / n)\n  return Math.cos(Math.PI / side);\n}\nfunction getStarAngle(side: number, radius: number) {\n  const cos = getCos(side);\n\n  return 100 * cos <= radius ? 0 :\n    Math.atan((cos - radius / 100) / Math.sin(Math.PI / side)) / Math.PI * 180;\n}\nfunction getSideSize(side: number, split: number,\n                     starAngle: number, strokeWidth: string | number) {\n  const starRatio = starAngle ? 1 / Math.cos(starAngle * Math.PI / 180) : 1;\n  let ratio = 1 / split;\n\n  if (side > 4) {\n    const sin = Math.sin(Math.PI / side);\n    const cos = Math.cos(Math.PI / side);\n\n    if (side % 4 === 0) {\n      // 2 * r * cos(180 / n) = w\n      // 2 * r * sin(180 / n) = size\n      ratio *= sin / cos;\n    } else if (side % 2 === 0) {\n      ratio *= sin;\n    } else {\n      // 2 * r * sin([n /2] * 180 / n) = w\n      // 2 * r * sin(180 / n) = size\n      ratio *= sin / getSin(side);\n    }\n  } else if (split === 1) {\n    return \"100%\";\n  }\n  ratio *= starRatio;\n\n  return `calc(100% * ${ratio} - ${strokeWidth} * ${ratio} + ${strokeWidth})`;\n}\nfunction getHeight(side: number, strokeWidth: string | number, isVertical: boolean) {\n  if (side % 4 === 0) {\n    return \"100%\";\n  }\n  const cos = getCos(side);\n\n  let ratio = 0;\n  if (side % 2 === 0) {\n    // w * cos = h (vertical)\n    // w / cos = h (horizontal)\n    ratio = isVertical ? cos : 1 / cos;\n  } else {\n    const sin = getSin(side);\n\n    if (isVertical) {\n      // 2 * r * sin([n /2] * 180 / n) = w\n      ratio = 0.5 / sin * (1 + cos);\n    } else {\n      // r * (1 + cos(180 / n)) = w\n      ratio = 2 * 1 / (1 + cos) * sin;\n    }\n  }\n  return `calc(100% * ${ratio} + ${strokeWidth} * ${1 - ratio})`;\n}\n\nfunction getFirstTransform(side: number, split: number, isVertical: boolean,\n                           starAngle: number, strokeValue: number, strokeUnit: string) {\n  const translateProperty = isVertical ? \"X\" : \"Y\";\n  const cos = Math.cos(starAngle * Math.PI / 180);\n\n  const arr = [];\n  arr.push(`translate${translateProperty}(-${50 * cos * split}%)`);\n  if (split > 1) {\n    arr.push(`translate${translateProperty}(${strokeValue / 2 * (cos * split - 1)}${strokeUnit})`);\n  }\n  if (starAngle !== 0) {\n    arr.push(`rotate(${starAngle}deg)`);\n  }\n  return `transform:${arr.join(\" \")};`;\n}\n\nfunction getAttribute(el: HTMLElement, name: string) {\n  return el.getAttribute(`data-${name}`) || undefined;\n}\nexport function dom(el: HTMLElement) {\n  const strokeWidth = getAttribute(el, \"stroke-width\");\n  const stroke = getAttribute(el, \"stroke\");\n  const direction = getAttribute(el, \"direction\") as DIRECTION;\n  let side: string | number = getAttribute(el, \"side\");\n  let split: string | number = getAttribute(el, \"split\");\n  let starRadius: string | number = getAttribute(el, \"star-radius\");\n\n  side && (side = parseFloat(side));\n  split && (split = parseFloat(split));\n  starRadius && (starRadius = parseFloat(starRadius));\n\n  return poly({\n    side: (side as number),\n    split: (split as number),\n    starRadius: (starRadius as number),\n    strokeWidth, direction, stroke, container: el});\n}\ninterface PolyInterface {\n  side?: number ;\n  split?: number;\n  strokeWidth: number | string;\n  className?: string;\n  starRadius?: number;\n  container?: HTMLElement;\n  direction?: DIRECTION;\n  stroke?: string;\n}\nexport function css({\n  strokeWidth = 0,\n  side = 3,\n  split = 1,\n  starRadius = 100,\n  stroke = \"black\",\n  direction = BOTTOM,\n}: PolyInterface) {\n  const splitCount = split * (starRadius === 100 ? 1 : 2);\n  const { unit: strokeUnit, value: strokeValue } = splitUnit(`${strokeWidth}`);\n  const half = `${strokeValue / 2}${strokeUnit}`;\n  const reverseDirection = REVERSE[direction];\n  const isVertical = direction === TOP || direction === BOTTOM;\n  const directionProperty = isVertical ? LEFT : TOP;\n  const otherDirectionProperty = isVertical ? TOP : LEFT;\n  const padding = getHeight(side, strokeWidth, isVertical);\n  const sign = direction === TOP || direction === RIGHT ? -1 : 1;\n  const starAngle = starRadius === 100 ? 0 : getStarAngle(side, starRadius);\n  const sideWidth = getSideSize(side, splitCount, starAngle, strokeWidth);\n  const width = isVertical ? sideWidth : strokeWidth;\n  const height = isVertical ? strokeWidth : sideWidth;\n  const externalAngle = 360 / side + 2 * starAngle;\n  const transformSplit = getFirstTransform(side, splitCount, isVertical, sign * starAngle, strokeValue, strokeUnit);\n  const sides = [];\n\n  sides.push(`${reverseDirection}:0;\n  ${otherDirectionProperty}:auto;\n  ${directionProperty}:50%;${transformSplit}${getTransformOrigin(half, isVertical)}\n  width:${width};height:${height};border-radius:${half};background:${stroke};`);\n  for (let i = 0; i < side; ++i) {\n    for (let j = 0; j < splitCount; ++j) {\n      const no = i * splitCount + j;\n\n      if (no === 0) {\n        continue;\n      }\n      const transform = j === 0 ? `transform:rotate(${sign * externalAngle}deg)` :\n        (starAngle && j === splitCount / 2 ? `transform:rotate(${-sign * 2 * starAngle}deg)` : \"transform:none;\");\n\n      sides.push(`${otherDirectionProperty}:auto;${directionProperty}: calc(100% - ${strokeWidth});${transform}`);\n    }\n  }\n  return { sides, percent: `padding-top:${padding}` };\n}\nexport function be(el: HTMLElement, {\n  strokeWidth = 0,\n  side = 3,\n  starRadius = 100,\n  stroke = \"black\",\n  direction = BOTTOM,\n}: PolyInterface) {\n  const sideElements = el.querySelectorAll(`.${SIDE_CLASS}`);\n  const length = sideElements.length;\n  const split = length / (side * (starRadius !== 100 ? 2 : 1));\n  if (!length || split % 1) {\n    return;\n  }\n  const percentElement = el.querySelector(`.${SIDE_CLASS}-percent`);\n  const {sides, percent} = css({strokeWidth, side, split, starRadius, stroke, direction});\n\n  sides.forEach((sideCSS, i) => {\n    (sideElements[i] as any).style.cssText += sideCSS;\n  });\n  (percentElement as any).style.cssText += percent;\n}\nexport function poly({\n  className = POLY_CLASS,\n  strokeWidth = 0,\n  side = 3,\n  split = 1,\n  starRadius = 100,\n  stroke = \"black\",\n  direction = BOTTOM,\n  container = makeDOM(\"div\", className),\n}: PolyInterface) {\n  const {sides, percent} = css({strokeWidth, side, split, starRadius, stroke, direction});\n  let html;\n\n  for (let i = sides.length - 1; i >= 1; --i) {\n    html = getHTML(` ${SIDE_CLASS}${i}`, SIDE_CSS + sides[i], html);\n  }\n  html = getHTML(` ${SIDE_CLASS}0`, `${POSITION_ABSOLUTE}display:inline-block;${sides[0]}`, html);\n\n  const percentHTML = getHTML(\"-percent\", `position:relative;width:100%;${percent}`);\n\n  const position = getComputedStyle(container).position;\n\n  if (!position || position === \"static\") {\n    container.style.position = \"relative\";\n  }\n  container.insertAdjacentHTML(\"beforeend\", html + percentHTML);\n\n  return container;\n}\n\nexport const VERSION = \"#__VERSION__#\";\n"],"names":["TOP","BOTTOM","LEFT","RIGHT","REVERSE","_a","POLY_CLASS","SIDE_CLASS","POSITION_ABSOLUTE","SIDE_CSS","getHTML","no","style","content","getSin","side","Math","sin","floor","PI","getCos","cos","getAttribute","el","name","undefined","css","radius","split","starAngle","strokeValue","strokeUnit","translateProperty","arr","strokeWidth","isVertical","_b","_c","_d","_e","starRadius","_f","stroke","_g","direction","splitCount","_h","text","matches","exec","unit","value","NaN","parseFloat","half","reverseDirection","directionProperty","otherDirectionProperty","padding","ratio","getHeight","sign","atan","sideWidth","starRatio","getSideSize","width","height","externalAngle","transformSplit","push","join","sides","i","j","transform","percent","poly","tag","className","html","_j","container","document","createElement","_k","length","percentHTML","position","getComputedStyle","insertAdjacentHTML","sideElements","querySelectorAll","percentElement","querySelector","forEach","sideCSS","cssText"],"mappings":"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"}